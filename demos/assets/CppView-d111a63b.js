import{_ as a,o as e,c as t,a as c}from"./index-49dfe5bc.js";const d=""+new URL("orbits_demo-31dba9c1.webm",import.meta.url).href,o=""+new URL("bullets_demo-034860e8.webm",import.meta.url).href,s=""+new URL("powdersim-1c544eda.webm",import.meta.url).href,i=""+new URL("solidsim-abf4e0f0.webm",import.meta.url).href,r=""+new URL("opengl_demo-82065403.webm",import.meta.url).href;const n={},l={class:"view-container"},p=c('<h1 data-v-c2cdc275>C++ Projects</h1><p data-v-c2cdc275>Here are some demos I have made in C++.</p><p data-v-c2cdc275>I learned how to program by reading <a href="https://www.stroustrup.com/4th.html" data-v-c2cdc275>&quot;The C++ Programming Language&quot;</a> by Bjarne Stroustrup</p><br data-v-c2cdc275><div class="video-post" data-v-c2cdc275><h2 data-v-c2cdc275>Orbiting planets</h2><div class="row" data-v-c2cdc275><video muted autoplay loop controls src="'+d+'" data-v-c2cdc275></video><div class="text-container" data-v-c2cdc275><p data-v-c2cdc275>After having read and done the exercises from the book, this was my first C++ project.</p><p data-v-c2cdc275>I checked some examples from <a href="https://www.raylib.com/examples.html" data-v-c2cdc275>Raylib</a> and then came up with this idea.</p><p data-v-c2cdc275>It has a main game loop, where the input processing, game update and drawing of objects are done separately.</p><p data-v-c2cdc275>Making the trails was a bit challenging since I didn&#39;t want to make any memory leaks.</p><br data-v-c2cdc275><br data-v-c2cdc275><p data-v-c2cdc275><a href="https://github.com/Forka137/orbiting-planets" data-v-c2cdc275>Code on Github</a></p></div></div></div><div class="video-post" data-v-c2cdc275><h2 data-v-c2cdc275>Bullet generator</h2><div class="row" data-v-c2cdc275><video muted autoplay loop controls src="'+o+'" data-v-c2cdc275></video><div class="text-container" data-v-c2cdc275><p data-v-c2cdc275>For this one I was inspired in the bullet system used in Touhou games. I also wanted to learn how to load assets.</p><p data-v-c2cdc275>The structure of the code is very similar to the orbiting planets. Every bullet deallocates its memory after leaving the screen.</p><p data-v-c2cdc275>The code allows to add easily more bullet patterns just by creating a new class with the pattern.</p><p data-v-c2cdc275>If you press the R you can spam thousands of bullets very quickly.</p><br data-v-c2cdc275><br data-v-c2cdc275><p data-v-c2cdc275><a href="https://github.com/Forka137/bullet-generator" data-v-c2cdc275>Code on Github</a></p></div></div></div><div class="video-post" data-v-c2cdc275><h2 data-v-c2cdc275>Powder Simulator</h2><div class="row" data-v-c2cdc275><video muted autoplay loop controls src="'+s+'" data-v-c2cdc275></video><div class="text-container" data-v-c2cdc275><p data-v-c2cdc275>I always wanted to make one of these simulators. It&#39;s based on the model of a &quot;Cellular Automaton&quot;. So basically each pixel will act different based on the pixel neighboring it.</p><p data-v-c2cdc275>In order to make it run faster I used the technique of &quot;grid based collision detection&quot;. So the pixel will only iterate with its neighbors instead of checking every pixel on the screen.</p><br data-v-c2cdc275><p data-v-c2cdc275>You can create sand, water and rock. More materials can be added easily by creating a new class.</p><br data-v-c2cdc275><br data-v-c2cdc275><p data-v-c2cdc275><a href="https://github.com/Forka137/powder-sim" data-v-c2cdc275>Code on Github</a></p></div></div></div><div class="video-post" data-v-c2cdc275><h2 data-v-c2cdc275>Solid Simulator</h2><div class="row" data-v-c2cdc275><video muted autoplay loop controls src="'+i+'" data-v-c2cdc275></video><div class="text-container" data-v-c2cdc275><p data-v-c2cdc275>After making the powder simulator I figure out making a physics simulator would be a nice challenge.</p><p data-v-c2cdc275>This one works using the &quot;Verlet integration method&quot; which is more accurate and stable than Euler&#39;s method.</p><p data-v-c2cdc275>I used the same optimization method as before (grid based collision detection). The objects will only check collision with the objects inside the neighboring spaces (9 spaces). This grid is visible on the screen.</p><br data-v-c2cdc275><p data-v-c2cdc275>You can change the object sizes and the color will cycle.</p><br data-v-c2cdc275><br data-v-c2cdc275><p data-v-c2cdc275><a href="https://github.com/Forka137/solid-sim" data-v-c2cdc275>Code on Github</a></p></div></div></div><div class="video-post" data-v-c2cdc275><h2 data-v-c2cdc275>OpenGL demo</h2><div class="row" data-v-c2cdc275><video muted autoplay loop controls src="'+r+'" data-v-c2cdc275></video><div class="text-container" data-v-c2cdc275><p data-v-c2cdc275>I was studying in parallel the book from <a href="https://learnopengl.com" data-v-c2cdc275>&quot;Learn OpenGL&quot;</a>. I had to learn about the rendering pipeline and shaders (GLSL).</p><p data-v-c2cdc275>I was able to understand the view frustum, matrix transformations, and even the problems of rotation in 3D space (Euler angles).</p><p data-v-c2cdc275>In the demo you can see a demo of 3D space, where there are 10 boxes being rendered. You move around with the WASD keys and the mouse.</p><p data-v-c2cdc275>There was an excercise in the book that required you to change the opacity of a texture using an &quot;uniform&quot; variable that is inside the shader. That&#39;s the frog texture you see at the end.</p><br data-v-c2cdc275><br data-v-c2cdc275><p data-v-c2cdc275><a href="https://github.com/Forka137/opengl-boxes" data-v-c2cdc275>Code on Github</a></p></div></div></div>',9),h=[p];function v(u,m){return e(),t("div",l,h)}const w=a(n,[["render",v],["__scopeId","data-v-c2cdc275"]]);export{w as default};
