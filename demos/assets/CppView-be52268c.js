import{_ as a,o as c,c as e,a as t}from"./index-52e44994.js";const o=""+new URL("orbits_demo-31dba9c1.webm",import.meta.url).href,d=""+new URL("bullets_demo-034860e8.webm",import.meta.url).href,i=""+new URL("powdersim-1c544eda.webm",import.meta.url).href,s=""+new URL("solidsim-abf4e0f0.webm",import.meta.url).href,r=""+new URL("doodle_jump-8b3c757b.webm",import.meta.url).href,n=""+new URL("opengl_demo-82065403.webm",import.meta.url).href;const l={},h={class:"view-container"},p=t('<h1 data-v-cd8cc0c5>C++ Projects</h1><p data-v-cd8cc0c5>Here are some demos I have made in C++.</p><p data-v-cd8cc0c5>I learned how to program by reading <a href="https://www.stroustrup.com/4th.html" data-v-cd8cc0c5>&quot;The C++ Programming Language&quot;</a> by Bjarne Stroustrup.</p><br data-v-cd8cc0c5><div class="video-post" data-v-cd8cc0c5><h2 data-v-cd8cc0c5>Orbiting planets</h2><div class="row" data-v-cd8cc0c5><video muted autoplay loop controls src="'+o+'" data-v-cd8cc0c5></video><div class="text-container" data-v-cd8cc0c5><p data-v-cd8cc0c5>This was my first C++ project. I checked some examples from <a href="https://www.raylib.com/examples.html" data-v-cd8cc0c5>Raylib</a> and then came up with this idea. It has a main game loop, where the input processing, game update and drawing of objects are done separately. Making the trails was a bit challenging since I didn&#39;t want to make any memory leaks.</p><br data-v-cd8cc0c5><p data-v-cd8cc0c5><a target="_blank" href="https://github.com/Forka137/orbiting-planets" data-v-cd8cc0c5>Code on Github</a></p><p data-v-cd8cc0c5><a target="_blank" href="https://drive.google.com/file/d/1lag2HEmJChQakpO8I1K9Ig0H4Kcl0TRq/view?usp=sharing" data-v-cd8cc0c5>Download (Win64)</a></p></div></div></div><div class="video-post" data-v-cd8cc0c5><h2 data-v-cd8cc0c5>Bullet generator</h2><div class="row" data-v-cd8cc0c5><video muted autoplay loop controls src="'+d+'" data-v-cd8cc0c5></video><div class="text-container" data-v-cd8cc0c5><p data-v-cd8cc0c5>For this one I was inspired in the bullet system used in Touhou games. I also wanted to learn how to load assets. The structure of the code is very similar to the orbiting planets. Every bullet deallocates its memory after leaving the screen. The code allows to add easily more bullet patterns just by creating a new class with the pattern.</p><p data-v-cd8cc0c5>If you press the R key you can spam thousands of bullets very quickly.</p><br data-v-cd8cc0c5><p data-v-cd8cc0c5><a target="_blank" href="https://github.com/Forka137/bullet-generator" data-v-cd8cc0c5>Code on Github</a></p><p data-v-cd8cc0c5><a target="_blank" href="https://drive.google.com/file/d/1EueUIjpaSgeJlc3ETnUQZIGYG1vXXP2D/view?usp=sharing" data-v-cd8cc0c5>Download (Win64)</a></p></div></div></div><div class="video-post" data-v-cd8cc0c5><h2 data-v-cd8cc0c5>Powder Simulator</h2><div class="row" data-v-cd8cc0c5><video muted autoplay loop controls src="'+i+'" data-v-cd8cc0c5></video><div class="text-container" data-v-cd8cc0c5><p data-v-cd8cc0c5>I always wanted to make one of these simulators. It&#39;s based on the model of a &quot;Cellular Automaton&quot;. Each pixel will act different based on the pixel neighboring it.</p><p data-v-cd8cc0c5>In order to make it run faster I used the technique of &quot;grid based collision detection&quot;. So the pixel will only iterate with its neighbors instead of checking every pixel on the screen.</p><br data-v-cd8cc0c5><p data-v-cd8cc0c5>You can create sand, water and rock. More materials can be added easily by creating a new class.</p><br data-v-cd8cc0c5><p data-v-cd8cc0c5><a target="_blank" href="https://github.com/Forka137/powder-sim" data-v-cd8cc0c5>Code on Github</a></p><p data-v-cd8cc0c5><a target="_blank" href="https://drive.google.com/file/d/1rsSP-GurvUqadeZshoC04ApLmR7fF209/view?usp=sharing" data-v-cd8cc0c5>Download (Win64)</a></p></div></div></div><div class="video-post" data-v-cd8cc0c5><h2 data-v-cd8cc0c5>Solid Simulator</h2><div class="row" data-v-cd8cc0c5><video muted autoplay loop controls src="'+s+'" data-v-cd8cc0c5></video><div class="text-container" data-v-cd8cc0c5><p data-v-cd8cc0c5>After making the powder simulator I figure out making a physics simulator would be a nice challenge. This one works using the &quot;Verlet integration method&quot; which is more accurate and stable than Euler&#39;s method. I used the same optimization method as before (grid based collision detection). The objects will only check collision with the objects inside the neighboring spaces (9 spaces). This grid is visible on the screen.</p><br data-v-cd8cc0c5><p data-v-cd8cc0c5>You can change the object sizes and the color will cycle.</p><br data-v-cd8cc0c5><p data-v-cd8cc0c5><a target="_blank" href="https://github.com/Forka137/solid-sim" data-v-cd8cc0c5>Code on Github</a></p><p data-v-cd8cc0c5><a target="_blank" href="https://drive.google.com/file/d/1_iADVeKO-FCtD9xoIymlhVHUa9oj1uaY/view?usp=sharing" data-v-cd8cc0c5>Download (Win64)</a></p></div></div></div><div class="video-post" data-v-cd8cc0c5><h2 data-v-cd8cc0c5>Doodle Jump Copy</h2><div class="row" data-v-cd8cc0c5><video muted autoplay loop controls src="'+r+'" data-v-cd8cc0c5></video><div class="text-container" data-v-cd8cc0c5><p data-v-cd8cc0c5>While looking for internships in game development I found one that required me to recreate the &quot;Doodle Jump&quot; mobile game on PC. I was given the sprites, a set of rules and objectives for the game. They provided a very basic framework for me to use.</p><br data-v-cd8cc0c5><p data-v-cd8cc0c5>Some characteristics of the game: Infinite scrolling, auto-restart, an static enemy, a shooter enemy, platform booster, and a powerup that makes you invincible.</p><br data-v-cd8cc0c5><p data-v-cd8cc0c5>This was made in 5 days for applying to <a target="_blank" href="https://dragonslake.com/" data-v-cd8cc0c5>Dragonslake&#39;s</a> Unreal Engine 5 internship. The version uploaded here has been ported to the Raylib&#39;s framework.</p><br data-v-cd8cc0c5><p data-v-cd8cc0c5><a target="_blank" href="https://drive.google.com/file/d/1A2F5lVH_f6IF-Mjid-ZexSMEBvn7ug-K/view?usp=sharing" data-v-cd8cc0c5>Download (Win64)</a></p></div></div></div><div class="video-post" data-v-cd8cc0c5><h2 data-v-cd8cc0c5>OpenGL demo</h2><div class="row" data-v-cd8cc0c5><video muted autoplay loop controls src="'+n+'" data-v-cd8cc0c5></video><div class="text-container" data-v-cd8cc0c5><p data-v-cd8cc0c5>I was studying in parallel the book from <a href="https://learnopengl.com" data-v-cd8cc0c5>&quot;Learn OpenGL&quot;</a>. I had to learn about the rendering pipeline and shaders (GLSL). I was able to understand the view frustum, matrix transformations, and even the problems of rotation in 3D space (Euler angles).</p><p data-v-cd8cc0c5>In the demo you can see a demo of 3D space, where there are 10 boxes being rendered. You move around with the WASD keys and the mouse.</p><br data-v-cd8cc0c5><p data-v-cd8cc0c5>There was an excercise in the book that required you to change the opacity of a texture using an &quot;uniform&quot; variable that is inside the shader. That&#39;s the frog texture you see at the end. There is no download since it is really basic.</p><br data-v-cd8cc0c5><p data-v-cd8cc0c5><a target="_blank" href="https://github.com/Forka137/opengl-boxes" data-v-cd8cc0c5>Code on Github</a></p></div></div></div>',10),v=[p];function m(u,g){return c(),e("div",h,v)}const w=a(l,[["render",m],["__scopeId","data-v-cd8cc0c5"]]);export{w as default};
